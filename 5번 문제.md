Q. 본인이 주력으로 사용하는 언어에서 자료구조와 관련 된 클래스가 내부적으로 어떻게 동작하는지 한 가지 사례를 정하여 작성해주세요.

A. HashMap의 선택이 많을 것으로 예상하고, 저는 ArrayList를 선택해 설명하겠습니다. 

ArrayList와 Array는 원소를 담는다는 점은 동일하지만, ArrayList는 동적으로 길이가 변할 수 있는 컬렉션이라는 점이 가장 큰 차이라고 할 수 있습니다.  

다만 내부적으로 ArrayList는 Array를 기반으로 동작한다는 점에 포커스를 두고 설명하겠습니다.  

https://github.com/AdoptOpenJDK/openjdk-jdk11/blob/master/src/java.base/share/classes/java/util/ArrayList.java 에서 알 수 있듯, ArrayList는 다음과 같이 동작합니다.  

1. new ArrayList<>()가 선언되면, initialCapacity 파라미터를 선언하지 않았을 경우 크기 10, 선언했을 경우 넣어준 파라미터에 맞는 크기의 Array가 만들어집니다.
2. 원소를 add할 경우 배열이 다 차지 않았다면 그대로 배열에 넣고, 배열의 크기를 넘어서는 경우 동적으로 배열의 크기를 늘립니다.
3. 원소를 remove할 경우 해당 원소의 자리를 null로 대입하고 기존에 있던 value를 반환합니다. 이 때, 현재 크기에서 -1 한 것이 지운 위치의 인덱스보다 크다면 arrayCopy가 일어납니다
4. 원소를 get할 경우는 Array와 같이 index로 접근합니다.  

여기서, ArrayList가 Array를 기반으로 동작한다는 것과 기본 동작을 알아보았으니 add나 remove할 경우 Array의 크기를 어떻게 늘리는지 알아보겠습니다.  

arrayCopy, copyOf를 이용하게 되고, 변하는 크기는 jdk 버전별로 다릅니다.  

jdk 6까지는 기존 배열의 길이의 1.5배씩 늘어나는 알고리즘이였습니다. 10 -> 15 -> 22 ... 의 형태로 늘어났습니다.  

즉, [크기가 늘어난 배열에 -> 기존의 원소를 복사] 하는 로직으로 동작하다 보니, 애초에 원소가 많이 들어갈 컬렉션일 경우, 초기 크기를 충분히 지정해주면 원소 복사에 해당하는 시간을 막을 수 있을 거라는 것을 알 수 있습니다.

때문에 jdk 7 부터는, newCapacity()메소드의 내부 로직이 바뀌었습니다.  

새로운 배열의 크기를 지정하는 메소드는 newCapacity()라는 메소드인데, jdk6과 7의 로직 일부를 보면 다음과 같습니다.  

jdk6 : int newCapacity = (oldCapacity * 3)/2 + 1;  
jdk7 : int newCapacity = oldCapacity + (oldCapacity >> 1);  

jdk6은 단순 연산으로 1.5배를 한 것과 달리, jdk7에서는 비트연산을 이용합니다. 보다 빠르게 배열을 생성하고 복사하는 시간을 단축하기 위함인 것을 알 수 있습니다.  

1.5배라는 수치 자체는 같습니다. 예를 들어, 10의 이진수인(1010)에 >> 1연산을 할 경우 101(5)이 되고, 전체적으로 10 + 5 = 15로 10의 1.5배를 한 15가 됩니다.  

때문에 시간 단축을위해 단순 연산에서 쉬프트연산으로 변경한 것의 차이지, 배열이 동적으로 늘어나는 수치 자체는 같습니다. 
